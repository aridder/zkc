// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use risc0_zkvm::{default_prover, ExecutorEnv, Receipt};
use serde::{Deserialize, Serialize};
use std::fs;

use methods::{JWT_VERIFY_ELF, JWT_VERIFY_ID};

#[derive(Serialize, Deserialize, Debug)]
struct PublicKeyHolder {
    public_key: String,
}

#[derive(Serialize, Deserialize, Debug, PartialEq)]
struct Proof {
    #[serde(rename = "type")]
    proof_type: String,
    jwt: String,
}


#[derive(Serialize, Deserialize, Debug)]
struct Credential {
    #[serde(rename = "credentialSubject")]
    credential_subject: serde_json::Value,
    issuer: serde_json::Value,
    #[serde(rename = "type")]
    types: Vec<String>,
    #[serde(rename = "@context")]
    context: Vec<String>,
    #[serde(rename = "issuanceDate")]
    issuance_date: String,
    proof: Proof,
}

#[derive(Serialize, Deserialize, Debug)]
struct Root {
    eidIssuer: PublicKeyHolder,
    bank: PublicKeyHolder,
    person: PublicKeyHolder,
    personCredential: Credential,
    houseLoanCredential: Credential,
}

fn prove_jwt_age_verification(
    age: u32,
    jwt: &str,
    public_key: &str,
) -> Receipt {
    let input = (age, jwt, public_key);
    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Produce a receipt by proving the specified ELF binary.
    prover.prove_elf(env, JWT_VERIFY_ELF).unwrap()
}

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    env_logger::init();

    // read json file from current directory
    let data = fs::read_to_string("./data.json").expect("Unable to read file");

    // Deserialize the JSON data
    println!("data: {:?}", data);
    let root: Root = serde_json::from_str(&data).expect("JSON was not well-formatted");

    // Initialize variables
    let public_key_eid = root.eidIssuer.public_key;
    let public_key_bob = root.person.public_key;
    let public_key_bank = root.bank.public_key;

    let person_credential = root.personCredential;
    let person_credential_jwt = person_credential.proof.jwt;
    let house_loan_credential = root.houseLoanCredential;

    let age = 33;
    let receipt = prove_jwt_age_verification(age, &person_credential_jwt, &public_key_eid);
    let (age): u32 = receipt.journal.decode().unwrap();
    println!("age: {:?}", age);
    // let signing_key = SigningKey::random(&mut OsRng); // Serialize with `::to_bytes()`
    // let message = b"This is a message that will be signed, and verified within the zkVM";
    // let signature:Signature = signing_key.sign(message);
    // let receipt = prove_ecdsa_verification(signing_key.verifying_key(), message, &signature);

    // let (encoded_verifying_key, receipt_message): (EncodedPoint, Vec<u8>) = receipt.journal.decode().unwrap();
    // let verifying_key = VerifyingKey::from_encoded_point(&encoded_verifying_key).unwrap();
    //
    // // print message in string
    // let message_str = String::from_utf8(receipt_message).unwrap();
    // println!("message_str: {:?}", message_str);

    // Optional: Verify receipt to confirm that recipients will also be able to
    // verify your receipt
    receipt.verify(JWT_VERIFY_ID).unwrap();

    println!("Receipt verified successfully!");
}
